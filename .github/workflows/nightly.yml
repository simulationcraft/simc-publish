name: Nightly

on:
  schedule:
    - cron: '0 0 * * *' # run at 0 AM UTC
  workflow_dispatch:
    inputs:
      justification:
        description: "Reason for manual run"
        required: true
      dryRun:
        description: "If true, do not upload files"
        default: true

env:
  SIMC_PROFILE: profiles/CI.simc
  ORG_NAME: simulationcraftorg
  IMAGE_NAME: simc

jobs:
  nightly-build:
    name:  Nightly ${{ matrix.target }} ${{ matrix.source_branch }}
    env:
        SIMCDIR: ${{ github.workspace }}
        INSTALL: ${{ github.workspace }}/install
        CMAKE_BUILD_DIR: ${{ github.workspace }}/builddir/
        uploadDir: ${{ github.workspace }}/upload
    strategy:        
      fail-fast: false
      matrix:
        source_branch: [shadowlands]
        target: [win64, winarm64, macos]
        qt_version: [6.2.4]
        qt_modules: ['qtwebengine qtwebchannel qtpositioning']
        include:
          - target: win64
            cl_architecture: x64
            package_suffix: win64
            qt_arch: win64_msvc2019_64
            smokeTest: true
            buildGui: ON
            os: windows-latest
          - target: winarm64
            cl_architecture: amd64_arm64
            package_suffix: winarm64
            # Use x64 qt installation for arm, since we can currently build cli only anyway, and require host qmake. If we ever want to fully build the GUI, we need to somehow get both win64_msvc2019_arm64 Qt as well as win64_msvc2019_64 for qmake set up. jurplel/install-qt-actio does not set up the qmake.bat from the arm64 install to correctly point to the x64 qmake.exe, and maybe does not even install it at all.
            qt_arch: win64_msvc2019_64
            smokeTest: false
            buildGui: OFF
            qt_modules: ''
            os: windows-latest          
          - target: macos
            package_suffix: macos
            qt_arch: ''
            smokeTest: true
            buildGui: ON
            os: macos-latest
    runs-on: windows-latest

    steps:
      - uses: actions/checkout@v2
        with:
          repository: simulationcraft/simc
          ref: ${{ matrix.source_branch }}

      - name: Get git hash
        id: git_hash
        shell: bash
        run: echo "::set-output name=sha_short::$(git rev-parse --short HEAD)"
        
      - name: Get cmake
        uses: lukka/get-cmake@latest
       
      - name: Add MSBuild and MS C++ Compiler to path
        if: ${{ matrix.os == 'windows-latest' }}
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: ${{ matrix.cl_architecture }}

      - name: Install Qt
        uses: jurplel/install-qt-action@v2
        with:
          modules: ${{ matrix.qt_modules }}
          arch: ${{ matrix.qt_arch }}
          setup-python: 'false'
          version: ${{ matrix.qt_version }}
          aqtversion: '==2.0.0'

      - name: Create Install and Upload Directory
        run: |
          mkdir ${{ env.INSTALL }}
          mkdir ${{ env.uploadDir }}
          
      - name: Extract Simc Version info and setup output information
        id: simc_info
        env:
          configHeader: engine/config.hpp
        shell: bash
        run: |
          export SIMC_MAJOR=$(grep -E -e "^#define SC_MAJOR_VERSION" "${{ env.configHeader }}" | sed -E -e "s/#define SC_MAJOR_VERSION \"([0-9]+)\"/\1/g")
          export SIMC_MINOR=$(grep -E -e "^#define SC_MINOR_VERSION" "${{ env.configHeader }}" | sed -E -e "s/#define SC_MINOR_VERSION \"([0-9]+)\"/\1/g")
          mkdir ${{ env.CMAKE_BUILD_DIR }}
          echo "$SIMC_MAJOR.$SIMC_MINOR" > ${{ env.CMAKE_BUILD_DIR }}/simc-version
          
      - name: Generate project files
        run: |
          cmake -B "${{ env.CMAKE_BUILD_DIR }}" -GNinja -DBUILD_GUI=${{ matrix.buildGui }} -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX:PATH=${{ steps.simc_info.outputs.install_dir}} -DSC_DEFAULT_APIKEY=${{ secrets.SC_DEFAULT_APIKEY }} -DCMAKE_INTERPROCEDURAL_OPTIMIZATION=1 -DCPACK_SYSTEM_NAME=${{ matrix.package_suffix }}
          
      - name: Build
        run: |
          cmake --build "${{ env.CMAKE_BUILD_DIR }}" --target all

      - name: Smoke Test
        if: ${{ matrix.smokeTest }}
        run: |
          & "${{ env.CMAKE_BUILD_DIR }}/simc.exe" ${{ env.SIMC_PROFILE }} iterations=5 output=nul html=nul json2=nul cleanup_threads=1
          
      - name: Package
        run: |
          cmake --build "${{ env.CMAKE_BUILD_DIR }}" --target package

      - uses: actions/upload-artifact@v2
        with:
          name: simc-nightly-${{ matrix.package_suffix }}-${{ matrix.source_branch }}
          path: |    
            ${{ env.CMAKE_BUILD_DIR }}/*.7z
            ${{ env.CMAKE_BUILD_DIR }}/simc-version

  nightly-upload:
    name: Nightly Upload ${{ matrix.source_branch }} ${{ matrix.package_suffix }}
    runs-on: ubuntu-latest
    needs: [nightly-build]
    if: ${{ github.event.inputs.dryRun != 'true' }}
    strategy:
      matrix:
        package_suffix: [win64, winarm64, macos]
        source_branch: [shadowlands]
        include:
          - package_suffix: win64
            file_extension: 7z
          - package_suffix: winarm64
            file_extension: 7z
          - package_suffix: macos
            file_extension: dmg

    steps:
      - name: Install sftp utils
        run: |
          sudo apt install sshpass

      - uses: actions/download-artifact@v2
        with:
          name: simc-nightly-${{ matrix.package_suffix }}-${{ matrix.source_branch }}
          path: ${{ github.workspace }}/artifacts

      # Use specific commit id here to fix known-hosts input not working.
      - name: SFTP Upload
        run: |
          export SIMCVERSION=$(cat ${{ env.local-dir }}/simc-version | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
          mkdir -p ~/.ssh
          echo "${{ secrets.UPLOAD_KNOWN_HOSTS }}" > ~/.ssh/known_hosts
          sshpass -e sftp -q ${{ secrets.UPLOAD_USER }}@${{ secrets.UPLOAD_HOST }}:${{ env.remote-dir }} <<< $"rm simc-$SIMCVERSION-${{ matrix.package_suffix }}-*.${{ matrix.file_extension }}"
          sshpass -e sftp -q ${{ secrets.UPLOAD_USER }}@${{ secrets.UPLOAD_HOST }}:${{ env.remote-dir }} <<< $"rm simc-$SIMCVERSION.*-${{ matrix.package_suffix }}.${{ matrix.file_extension }}"
          sshpass -e sftp -q ${{ secrets.UPLOAD_USER }}@${{ secrets.UPLOAD_HOST }}:${{ env.remote-dir }} <<< $'put ${{ env.local-dir }}/*.${{ matrix.file_extension }}'

        env:
          SSHPASS: ${{ secrets.UPLOAD_PASSWORD }}
          known-hosts: ${{ secrets.UPLOAD_KNOWN_HOSTS }}
          remote-dir: /
          local-dir: ${{ github.workspace }}/artifacts

  docker-image-create-and-publish:
    # TODO: this approach could be improved by doing a matrix build like the above jobs do
    # matrix could be branch and threads
    # threads could be used for different tagged versions too
    needs: [nightly-build]
    runs-on: ubuntu-latest

    steps:
      - name: Download SimulationCraft
        run: |
          git clone --depth 1 --single-branch https://github.com/simulationcraft/simc.git simc

      - name: Get SimulationCraft version
        run: |
          echo "SIMC_VERSION=$(grep 'SIMC_WOW_VERSION' engine/dbc/generated/client_data_version.inc | sed -E -e 's/#define SIMC_WOW_VERSION \"(.+)\"/\1/')" >> $GITHUB_ENV
        working-directory: ./simc

      - name: Get SimulationCraft version
        run: |
          echo "SIMC_HASH=$(git rev-parse --short HEAD)" >> $GITHUB_ENV
        working-directory: ./simc

      - name: Get date
        run: |
          echo "DATE=$(date +'%Y-%m-%d')" >> $GITHUB_ENV
        working-directory: ./simc

      - name: Create full version string
        run: |
          echo "VERSION_STRING=$SIMC_VERSION-$DATE-$SIMC_HASH" >> $GITHUB_ENV

      - name: Build image
        run: |
          docker build . --file Dockerfile --build-arg APIKEY=${{ secrets.SC_DEFAULT_APIKEY }} --tag $IMAGE_NAME:$VERSION_STRING --tag $IMAGE_NAME:latest
        working-directory: ./simc

      - name: Log into registry
        run: echo "${{ secrets.DOCKERHUB }}" | docker login -u ${{ secrets.DOCKERHUBUSER }} --password-stdin

      - name: Push image
        run: |
          IMAGE_ID=$ORG_NAME/$IMAGE_NAME

          docker tag $IMAGE_NAME:$VERSION_STRING $IMAGE_ID:$VERSION_STRING
          docker tag $IMAGE_NAME:latest $IMAGE_ID:latest

          docker push $IMAGE_ID:$VERSION_STRING
          docker push $IMAGE_ID:latest
